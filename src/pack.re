
open Types;

let cat = (filename) => {
  let ic = open_in_bin(filename);
  let len = in_channel_length(ic);
  let buf = Buffer.create(len);
  Buffer.add_channel(buf, ic, len);
  let content = Buffer.contents(buf);
  close_in(ic);
  content
};

let abspath = (path) => {
  let path = if (path.[0] == '.') {
    Filename.concat(Unix.getcwd(), path)
  } else {
    path
  };
  let parts = Str.split(Str.regexp("/"), path);
  let parts = ["", ...parts];
  let rec loop = (items) => switch items {
  | [] => []
  | [".", ...rest] => loop(rest)
  | ["..", ...rest] => ["..", ...loop(rest)]
  | [_, "..", ...rest] => loop(rest)
  | [item, ...rest] => [item, ...loop(rest)]
  };
  let rec chug = (items) => {
    let next = loop(items);
    if (next != items) {
      chug(next)
    } else {
      items
    }
  };
  String.concat(Filename.dir_sep, chug(parts))
};

let rec process = (state, path) => {
  let path = abspath(path);
  if (Hashtbl.mem(state.ids, path)) {
    Hashtbl.find(state.ids, path);
  } else {
    state.nextId = state.nextId + 1;
    let id = state.nextId;
    Hashtbl.add(state.ids, path, id);
    let contents = cat(path);
    let requires = FindRequires.parseContents(path, contents);
    /* let requires = []; */
    let fixed = FixFile.process(state, path, contents, requires, process);
    state.modules = [(id, path, fixed), ...state.modules];
    id
  }
};

let mapOf = List.fold_left((m, (a, b)) => StrMap.add(a, b, m), StrMap.empty);

let makeRelative = (a, b) => {
  if (String.length(b) > String.length(a)) {
    if (String.sub(b, 0, String.length(a)) == a) {
      let res = String.sub(b, String.length(a), String.length(b) - String.length(a));
      if (res.[0] == '/') {
        "." ++ res
      } else {
        res
      }
    } else {
      b
    }
  } else {
    b
  }
};

let process = (~renames, ~base=Unix.getcwd(), abspath) => {
  let state = {
    entry: abspath,
    alias: mapOf(renames),
      /* [
      ("Reprocessing", "@jaredly/reprocessing"),
      ("ReasonglWeb", "@jaredly/reasongl-web"),
      ("ReasonglInterface", "@jaredly/reasongl-interface"),
    ]), */
    base,
    /* nodeModulesBase: "../../games/gravitron/node_modules", */
    ids: Hashtbl.create(100),
    nextId: 0,
    modules: []
  };
  process(state, abspath) |> ignore;
  {|
;(function() { // generated by pack.re
let modules = {}
let initializers = {
    |} ++ (List.map(
    ((id, path, body)) => string_of_int(id) ++ ": function(module, exports, require) {" ++  body
     ++ "\n//# sourceURL=" ++ makeRelative(base, path) ++ "\n}",
    state.modules
  ) |> String.concat(",\n  "))
  ++ {|
};
let require = (id) => {
  if (!modules[id]) {
    modules[id] = {exports: {}}
    initializers[id](modules[id], modules[id].exports, require)
  }
  return modules[id].exports
};
require(1)
})();
  |}
};

let parse = Minimist.parse(~alias=[("h", "help")], ~presence=["help"], ~multi=["rename"], ~strings=["base"]);

let help = {|
# pack.re - a simple js bundler for reason

Usage: pack.re [options] entry-file.js > bundle.js

  --base (default: current directory)
      expected to contain node_modules
  --rename newName=realName (can be defined multiple times)
      maps `require("newName")` to a node_module called "realName"
  -h, --help
      print this help
|};

let fail = (msg) => {
  print_endline(msg);
  print_endline(help);
  exit(1);
};

switch (parse(List.tl(Array.to_list(Sys.argv)))) {
| Minimist.Error(err) => fail(Minimist.report(err))
| Ok(opts) =>
if (Minimist.StrSet.mem("help", opts.presence)) {
  print_endline(help); exit(0);
} else switch (opts.rest) {
  | [] => fail("Expected entry file as final argument")
  | [entry] => process(
      ~base=?Minimist.get(opts.strings, "base"),
      ~renames=
        List.map(item => switch (Str.split(Str.regexp("="), item)) {
        | [alias, m] => (alias, m)
        | _ => fail("Expected rename argument to be of the form alias=realname")
        }, Minimist.multi(opts.multi, "rename")),
      entry
    ) |> print_endline
  | _ => fail("Only one entry file allowed")
}
};

/* switch Sys.argv {
| [|_, arg|] => process(Sys.argv[1]) |> print_endline
| _ => print_endline()
}; */