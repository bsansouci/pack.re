
open Types;

let abspath = (path) => {
  let path = if (path.[0] == '.') {
    Filename.concat(Unix.getcwd(), path)
  } else {
    path
  };
  let parts = Str.split(Str.regexp("/"), path);
  let parts = ["", ...parts];
  let rec loop = (items) => switch items {
  | [] => []
  | [".", ...rest] => loop(rest)
  | ["..", ...rest] => ["..", ...loop(rest)]
  | [_, "..", ...rest] => loop(rest)
  | [item, ...rest] => [item, ...loop(rest)]
  };
  let rec chug = (items) => {
    let next = loop(items);
    if (next != items) {
      chug(next)
    } else {
      items
    }
  };
  String.concat(Filename.dir_sep, chug(parts))
};

let unwrap = (message, v) => switch v { | None => failwith(message) | Some(v) => v };

let rec process = (state, path) => {
  let path = abspath(path);
  if (Hashtbl.mem(state.ids, path)) {
    Hashtbl.find(state.ids, path);
  } else {
    state.nextId = state.nextId + 1;
    let id = state.nextId;
    Hashtbl.add(state.ids, path, id);
    let contents = ReasonCliTools.Files.readFile(path) |> unwrap("Required file not found: " ++ path);
    let requires = FindRequires.parseContents(path, contents);
    /* let requires = []; */
    let fixed = FixFile.process(state, path, contents, requires, process);
    state.modules = [(id, path, fixed), ...state.modules];
    id
  }
};

let mapOf = List.fold_left((m, (a, b)) => StrMap.add(a, b, m), StrMap.empty);

let makeRelative = (a, b) => {
  if (String.length(b) > String.length(a)) {
    if (String.sub(b, 0, String.length(a)) == a) {
      let res = String.sub(b, String.length(a), String.length(b) - String.length(a));
      if (res.[0] == '/') {
        "." ++ res
      } else {
        res
      }
    } else {
      b
    }
  } else {
    b
  }
};

let formatBundle = (base, modules) => {
  {|
;(function() { // generated by pack.re
let modules = {}
let initializers = {
    |} ++ (List.map(
    ((id, path, body)) => string_of_int(id) ++ ": function(module, exports, require) {" ++  body
     ++ "\n//# sourceURL=" ++ makeRelative(base, path) ++ "\n}",
    modules
  ) |> String.concat(",\n  "))
  ++ {|
};
let require = (id) => {
  if (!modules[id]) {
    modules[id] = {exports: {}}
    initializers[id](modules[id], modules[id].exports, require)
  }
  return modules[id].exports
};
require(1)
})();
  |}
};

let process = (~renames, ~base=Unix.getcwd(), abspath) => {
  let state = {
    entry: abspath,
    alias: mapOf(renames),
    base,
    ids: Hashtbl.create(100),
    nextId: 0,
    modules: []
  };
  process(state, abspath) |> ignore;
  formatBundle(base, state.modules)
};